/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set ts=8 sts=2 et sw=2 tw=80: */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#ifndef BaseProfilerUtils_h
#define BaseProfilerUtils_h

// This header contains most process- and thread-related functions.
// It is safe to include unconditionally.

#include "mozilla/Assertions.h"

#include <type_traits>

namespace mozilla::baseprofiler {

// Trivially-copyable class containing a process id. It may be left unspecified.
class BaseProfilerProcessId {
 public:
  // Unspecified process id.
  constexpr BaseProfilerProcessId() = default;

  [[nodiscard]] constexpr bool IsSpecified() const {
    return mProcessId != scUnspecified;
  }

  using NumberType = int;

  // Get the process id as a number, which may be unspecified.
  // This should only be used for serialization or logging.
  [[nodiscard]] constexpr NumberType ToNumber() const { return mProcessId; }

  // BaseProfilerProcessId from given number (which may be unspecified).
  constexpr static BaseProfilerProcessId FromNumber(
      const NumberType& aProcessId) {
    return BaseProfilerProcessId{aProcessId};
  }

  [[nodiscard]] constexpr bool operator==(
      const BaseProfilerProcessId& aOther) const {
    return mProcessId == aOther.mProcessId;
  }
  [[nodiscard]] constexpr bool operator!=(
      const BaseProfilerProcessId& aOther) const {
    return mProcessId != aOther.mProcessId;
  }

 private:
  constexpr explicit BaseProfilerProcessId(const NumberType& aProcessId)
      : mProcessId(aProcessId) {}

  static constexpr NumberType scUnspecified = 0;
  NumberType mProcessId = scUnspecified;
};

// Check traits. These should satisfy usage in std::atomic.
static_assert(std::is_trivially_copyable_v<BaseProfilerProcessId>);
static_assert(std::is_copy_constructible_v<BaseProfilerProcessId>);
static_assert(std::is_move_constructible_v<BaseProfilerProcessId>);
static_assert(std::is_copy_assignable_v<BaseProfilerProcessId>);
static_assert(std::is_move_assignable_v<BaseProfilerProcessId>);

// Trivially-copyable class containing a thread id. It may be left unspecified.
class BaseProfilerThreadId {
 public:
  // Unspecified thread id.
  constexpr BaseProfilerThreadId() = default;

  [[nodiscard]] constexpr bool IsSpecified() const {
    return mThreadId != scUnspecified;
  }

  using NumberType = int;

  // Get the thread id as a number, which may be unspecified.
  // This should only be used for serialization or logging.
  [[nodiscard]] constexpr NumberType ToNumber() const { return mThreadId; }

  // BaseProfilerThreadId from given number (which may be unspecified).
  constexpr static BaseProfilerThreadId FromNumber(
      const NumberType& aThreadId) {
    return BaseProfilerThreadId{aThreadId};
  }

  [[nodiscard]] constexpr bool operator==(
      const BaseProfilerThreadId& aOther) const {
    return mThreadId == aOther.mThreadId;
  }
  [[nodiscard]] constexpr bool operator!=(
      const BaseProfilerThreadId& aOther) const {
    return mThreadId != aOther.mThreadId;
  }

 private:
  constexpr explicit BaseProfilerThreadId(const NumberType& aThreadId)
      : mThreadId(aThreadId) {}

  static constexpr NumberType scUnspecified = 0;
  NumberType mThreadId = scUnspecified;
};

// Check traits. These should satisfy usage in std::atomic.
static_assert(std::is_trivially_copyable_v<BaseProfilerThreadId>);
static_assert(std::is_copy_constructible_v<BaseProfilerThreadId>);
static_assert(std::is_move_constructible_v<BaseProfilerThreadId>);
static_assert(std::is_copy_assignable_v<BaseProfilerThreadId>);
static_assert(std::is_move_assignable_v<BaseProfilerThreadId>);

}  // namespace mozilla::baseprofiler

#ifndef MOZ_GECKO_PROFILER

namespace mozilla::baseprofiler {

[[nodiscard]] inline BaseProfilerProcessId profiler_current_process_id() {
  return BaseProfilerProcessId{};
}
[[nodiscard]] inline BaseProfilerThreadId profiler_current_thread_id() {
  return BaseProfilerThreadId{};
}
[[nodiscard]] inline BaseProfilerThreadId profiler_main_thread_id() {
  return BaseProfilerThreadId{};
}
[[nodiscard]] inline bool profiler_is_main_thread() { return false; }

}  // namespace mozilla::baseprofiler

#else  // !MOZ_GECKO_PROFILER

#  include "mozilla/Types.h"

namespace mozilla::baseprofiler {

// Get the current process's ID.
[[nodiscard]] MFBT_API BaseProfilerProcessId profiler_current_process_id();

// Get the current thread's ID.
[[nodiscard]] MFBT_API BaseProfilerThreadId profiler_current_thread_id();

namespace detail {
// Statically initialized to 0, then set once from profiler_init(), which should
// be called from the main thread before any other use of the profiler.
extern MFBT_DATA BaseProfilerThreadId scProfilerMainThreadId;
}  // namespace detail

[[nodiscard]] inline BaseProfilerThreadId profiler_main_thread_id() {
  return detail::scProfilerMainThreadId;
}

[[nodiscard]] inline bool profiler_is_main_thread() {
  return profiler_current_thread_id() == profiler_main_thread_id();
}

}  // namespace mozilla::baseprofiler

#endif  // !MOZ_GECKO_PROFILER

#endif  // BaseProfilerUtils_h
